"""Unit tests untuk feature engineering module."""

import pytest\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\n\nfrom app.features.engineering import FeatureEngineer\n\n\nclass TestFeatureEngineer:\n    \"\"\"Test suite untuk FeatureEngineer class.\"\"\"\n    \n    def test_init(self):\n        \"\"\"Test FeatureEngineer initialization.\"\"\"\n        fe = FeatureEngineer()\n        assert fe.scalers == {}\n        assert fe.feature_metadata == {}\n    \n    def test_engineer_features_basic(self, sample_price_data: pd.DataFrame):\n        \"\"\"Test basic feature engineering.\"\"\"\n        fe = FeatureEngineer()\n        \n        features_df = fe.engineer_features(\n            price_data=sample_price_data,\n            commodity_code=\"BERAS\"\n        )\n        \n        # Check that features were added\n        assert len(features_df.columns) > len(sample_price_data.columns)\n        assert 'price' in features_df.columns\n        assert features_df.index.name == 'date' or 'date' in features_df.columns\n    \n    def test_technical_indicators(self, sample_price_data: pd.DataFrame):\n        \"\"\"Test technical indicators generation.\"\"\"\n        fe = FeatureEngineer()\n        df = sample_price_data.set_index('date')\n        \n        result_df = fe._add_technical_indicators(df)\n        \n        # Check moving averages\n        expected_ma_cols = ['ma_7', 'ma_14', 'ma_30']\n        for col in expected_ma_cols:\n            assert col in result_df.columns\n            assert not result_df[col].isna().all()\n        \n        # Check RSI\n        assert 'rsi' in result_df.columns\n        # RSI should be between 0 and 100\n        rsi_values = result_df['rsi'].dropna()\n        if len(rsi_values) > 0:\n            assert rsi_values.min() >= 0\n            assert rsi_values.max() <= 100\n        \n        # Check MACD\n        macd_cols = ['ema_12', 'ema_26', 'macd', 'macd_signal']\n        for col in macd_cols:\n            assert col in result_df.columns\n        \n        # Check Bollinger Bands\n        bb_cols = ['bb_middle', 'bb_upper', 'bb_lower', 'bb_width']\n        for col in bb_cols:\n            assert col in result_df.columns\n    \n    def test_seasonal_features(self, sample_price_data: pd.DataFrame):\n        \"\"\"Test seasonal feature generation.\"\"\"\n        fe = FeatureEngineer()\n        df = sample_price_data.set_index('date')\n        \n        result_df = fe._add_seasonal_features(df)\n        \n        # Check time-based features\n        time_features = ['year', 'month', 'day', 'day_of_week', 'day_of_year', 'quarter']\n        for col in time_features:\n            assert col in result_df.columns\n        \n        # Check cyclical encoding\n        cyclical_features = ['month_sin', 'month_cos', 'day_of_week_sin', 'day_of_week_cos']\n        for col in cyclical_features:\n            assert col in result_df.columns\n            # Sine and cosine should be between -1 and 1\n            values = result_df[col].dropna()\n            if len(values) > 0:\n                assert values.min() >= -1.1  # Small tolerance for numerical errors\n                assert values.max() <= 1.1\n        \n        # Check seasonal patterns\n        seasonal_cols = ['is_dry_season', 'is_wet_season', 'is_rice_harvest']\n        for col in seasonal_cols:\n            assert col in result_df.columns\n            # Should be binary (0 or 1)\n            values = result_df[col].dropna().unique()\n            assert set(values).issubset({0, 1})\n    \n    def test_lag_features(self, sample_price_data: pd.DataFrame):\n        \"\"\"Test lag feature generation.\"\"\"\n        fe = FeatureEngineer()\n        df = sample_price_data.set_index('date')\n        \n        result_df = fe._add_lag_features(df)\n        \n        # Check lagged prices\n        lag_periods = [1, 2, 3, 7, 14, 30]\n        for lag in lag_periods:\n            col_name = f'price_lag_{lag}'\n            assert col_name in result_df.columns\n            \n            # Check that lag is working correctly (non-null values)\n            non_null_count = result_df[col_name].notna().sum()\n            assert non_null_count > 0\n    \n    def test_volatility_features(self, sample_price_data: pd.DataFrame):\n        \"\"\"Test volatility feature generation.\"\"\"\n        fe = FeatureEngineer()\n        df = sample_price_data.set_index('date')\n        \n        result_df = fe._add_volatility_features(df)\n        \n        # Check volatility features\n        volatility_cols = ['volatility_7', 'volatility_30', 'returns', 'returns_squared']\n        for col in volatility_cols:\n            assert col in result_df.columns\n        \n        # Volatility should be non-negative\n        for window in [7, 30]:\n            vol_col = f'volatility_{window}'\n            if vol_col in result_df.columns:\n                vol_values = result_df[vol_col].dropna()\n                if len(vol_values) > 0:\n                    assert (vol_values >= 0).all()\n    \n    def test_weather_features(self, sample_price_data: pd.DataFrame, sample_weather_data: pd.DataFrame):\n        \"\"\"Test weather feature integration.\"\"\"\n        fe = FeatureEngineer()\n        \n        features_df = fe.engineer_features(\n            price_data=sample_price_data,\n            weather_data=sample_weather_data,\n            commodity_code=\"BERAS\"\n        )\n        \n        # Check that weather features were added\n        weather_feature_cols = [col for col in features_df.columns if 'weather_' in col]\n        assert len(weather_feature_cols) > 0\n        \n        # Check specific weather features\n        expected_weather_features = ['weather_temperature', 'weather_rainfall', 'weather_humidity']\n        for feature in expected_weather_features:\n            # Feature might exist with different naming\n            weather_cols = [col for col in features_df.columns if feature.replace('weather_', '') in col.lower()]\n            assert len(weather_cols) > 0\n    \n    def test_clean_features(self, sample_features_data: pd.DataFrame):\n        \"\"\"Test feature cleaning functionality.\"\"\"\n        fe = FeatureEngineer()\n        \n        # Add some problematic values\n        df_dirty = sample_features_data.copy()\n        df_dirty.loc[0, 'price_ma_7'] = np.inf\n        df_dirty.loc[1, 'price_ma_30'] = -np.inf\n        df_dirty.loc[2, 'volatility_7d'] = np.nan\n        \n        cleaned_df = fe._clean_features(df_dirty)\n        \n        # Check that infinite values are removed\n        assert not np.isinf(cleaned_df.select_dtypes(include=[np.number])).any().any()\n        \n        # Check that most NaN values are filled\n        nan_percentage = cleaned_df.isnull().sum().sum() / (cleaned_df.shape[0] * cleaned_df.shape[1])\n        assert nan_percentage < 0.1  # Less than 10% NaN values\n    \n    def test_get_feature_importance_names(self, sample_features_data: pd.DataFrame):\n        \"\"\"Test feature importance names extraction.\"\"\"\n        fe = FeatureEngineer()\n        \n        feature_names = fe.get_feature_importance_names(sample_features_data)\n        \n        # Should exclude target and identifier columns\n        excluded_cols = ['price', 'commodity_code', 'region_code', 'commodity_name', 'region_name']\n        for col in excluded_cols:\n            assert col not in feature_names\n        \n        # Should include engineered features\n        assert 'price_ma_7' in feature_names\n        assert 'month' in feature_names\n    \n    def test_scale_features(self, sample_features_data: pd.DataFrame):\n        \"\"\"Test feature scaling functionality.\"\"\"\n        fe = FeatureEngineer()\n        \n        feature_cols = fe.get_feature_importance_names(sample_features_data)\n        numeric_features = sample_features_data[feature_cols].select_dtypes(include=[np.number]).columns.tolist()\n        \n        # Test standard scaling\n        scaled_df = fe.scale_features(\n            sample_features_data, \n            numeric_features[:5],  # Use first 5 numeric features\n            scaler_type='standard',\n            fit_scaler=True\n        )\n        \n        # Check that scaler was fitted\n        assert 'standard_scaler' in fe.scalers\n        \n        # Check that values are scaled (approximately mean 0, std 1)\n        for col in numeric_features[:5]:\n            if col in scaled_df.columns:\n                values = scaled_df[col].dropna()\n                if len(values) > 1:\n                    assert abs(values.mean()) < 0.1  # Close to 0\n                    assert abs(values.std() - 1) < 0.1  # Close to 1\n    \n    def test_create_feature_summary(self, sample_features_data: pd.DataFrame):\n        \"\"\"Test feature summary creation.\"\"\"\n        fe = FeatureEngineer()\n        \n        summary = fe.create_feature_summary(sample_features_data)\n        \n        # Check summary structure\n        assert 'total_features' in summary\n        assert 'feature_categories' in summary\n        assert 'data_quality' in summary\n        assert 'feature_list' in summary\n        \n        # Check that feature categories are properly counted\n        feature_categories = summary['feature_categories']\n        assert 'technical' in feature_categories\n        assert 'seasonal' in feature_categories\n        assert 'statistical' in feature_categories\n        \n        # Check data quality metrics\n        data_quality = summary['data_quality']\n        assert 'total_samples' in data_quality\n        assert 'missing_values' in data_quality\n        assert 'missing_percentage' in data_quality\n        \n        # Validate values\n        assert summary['total_features'] > 0\n        assert data_quality['total_samples'] == len(sample_features_data)\n    \n    def test_engineer_features_with_empty_data(self):\n        \"\"\"Test feature engineering with empty data.\"\"\"\n        fe = FeatureEngineer()\n        empty_df = pd.DataFrame()\n        \n        with pytest.raises((ValueError, KeyError)):\n            fe.engineer_features(empty_df, commodity_code=\"BERAS\")\n    \n    def test_engineer_features_minimal_data(self):\n        \"\"\"Test feature engineering with minimal data.\"\"\"\n        fe = FeatureEngineer()\n        \n        # Create minimal dataset\n        minimal_data = pd.DataFrame({\n            'date': pd.date_range('2024-01-01', periods=5, freq='D'),\n            'price': [10000, 10100, 9950, 10050, 10200],\n            'commodity_code': 'BERAS',\n            'region_code': '31'\n        })\n        \n        # Should not raise an error\n        result_df = fe.engineer_features(minimal_data, commodity_code=\"BERAS\")\n        \n        # Should have some features\n        assert len(result_df.columns) >= len(minimal_data.columns)\n        assert len(result_df) <= len(minimal_data)  # Some rows might be dropped due to NaN\n    \n    @pytest.mark.parametrize(\"scaler_type\", [\"standard\", \"minmax\"])\n    def test_different_scalers(self, sample_features_data: pd.DataFrame, scaler_type: str):\n        \"\"\"Test different scaler types.\"\"\"\n        fe = FeatureEngineer()\n        \n        feature_cols = ['price_ma_7', 'price_ma_30']\n        \n        scaled_df = fe.scale_features(\n            sample_features_data,\n            feature_cols,\n            scaler_type=scaler_type,\n            fit_scaler=True\n        )\n        \n        # Check that scaler was fitted\n        scaler_key = f\"{scaler_type}_scaler\"\n        assert scaler_key in fe.scalers\n        \n        # Check that values are properly scaled\n        for col in feature_cols:\n            if col in scaled_df.columns:\n                values = scaled_df[col].dropna()\n                if len(values) > 1:\n                    if scaler_type == \"minmax\":\n                        # MinMax should be between 0 and 1\n                        assert values.min() >= -0.1  # Small tolerance\n                        assert values.max() <= 1.1\n                    elif scaler_type == \"standard\":\n                        # Standard should have mean ~0, std ~1\n                        assert abs(values.mean()) < 0.1\n                        assert abs(values.std() - 1) < 0.1\n